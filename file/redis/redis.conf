#Redis配置文件示例。
#
#注意，为了读取配置文件，Redis必须
#以文件路径作为第一个参数开始：
#
# ./redis-server /path/to/redis.conf

#关于单位的说明：当需要内存大小时，可以指定
#它通常采用1k 5GB 4M等形式：
#
#1k=>1000字节
#1kb=>1024字节
#1m=>1000000字节
#1mb=>1024*1024字节
#1g=>1000000000字节
#1gb=>1024*1024*1024字节
#
#单元不区分大小写，所以1GB 1GB都是一样的。

################################## INCLUDES (包括) ###################################

#在此处包含一个或多个其他配置文件。这是有用的，如果你
#有一个标准的模板，去所有的Redis服务器，但也需要
#自定义每个服务器的一些设置。包含文件可以包含
#其他文件，所以明智地使用它。
#
#请注意，命令“CONFIG REWRITE”不会重写选项“include”
#来自管理员或Redis Sentinel。因为Redis总是使用最后处理的
#行作为配置指令的值，最好将includes
#以避免在运行时覆盖配置更改。
#
#如果您对使用includes覆盖配置感兴趣
#选项，最好使用include作为最后一行。
#
# include /path/to/local.conf
# include /path/to/other.conf

################################## MODULES (模块) #####################################

#启动时加载模块。如果服务器无法加载模块
#它将中止。可以使用多个loadmodule指令。
#
# loadmodule /path/to/my_module.so
# loadmodule /path/to/other_module.so

################################## NETWORK (NETWORK)#####################################

#默认情况下，如果没有指定“bind”配置指令，Redis将侦听
#用于主机上所有可用网络接口的连接。
#可以使用以下命令只侦听一个或多个选定的接口
#“bind”配置指令，后跟一个或多个IP地址。
#每个地址的前缀可以是“-”，这意味着redis不会失败
#如果地址不可用，则启动。不可用仅指
#与任何网络接口都不对应的地址。地址
#已在使用的协议将始终失败，并且不受支持的协议将始终失败
#悄悄跳过。
#
#示例：
#
#bind 192.168.1.100 10.0.0.1#侦听两个特定的IPv4地址
#bind 127.0.0.1:：1#侦听环回IPv4和IPv6
#绑定*-：*#与默认值一样，所有可用接口
#
#~~~警告~~~如果运行Redis的计算机直接暴露于
#在internet上，绑定到所有接口是危险的，并且会暴露
#向互联网上的每个人提供实例。因此默认情况下，我们取消注释
#遵循bind指令，这将强制Redis只在
#IPv4和IPv6（如果可用）环回接口地址（这意味着Redis
#将只能接受来自同一主机的客户端连接
#正在运行）。
#
#如果您确定希望实例侦听所有接口
#把下面这行注释掉。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#bind 127.0.0.1 -::1

#保护模式是一层安全保护，以避免这种情况
#互联网上开放的Redis实例被访问和利用。
#
#打开保护模式时，如果：
#
#1）服务器没有使用
#“绑定”指令。
#2）未配置密码。
#
#服务器只接受来自从服务器连接的客户端的连接
#IPv4和IPv6环回地址127.0.0.1和：：1，并且来自Unix域
#插座。
#
#默认情况下，启用保护模式。你应该禁用它只有在
#您确定希望其他主机的客户端连接到Redis吗
#即使没有配置身份验证，也没有特定的一组接口
#使用“bind”指令显式列出。
protected-mode no

#接受指定端口上的连接，默认值为6379（IANA#815344）。
#如果指定了端口0，Redis将不会侦听TCP套接字。
port 6379

#TCP listen（）积压工作。
#
#在每秒请求数高的环境中，您需要一个高的积压工作
#以避免客户端连接速度慢的问题。请注意，Linux内核
#将静默地将其截断为/proc/sys/net/core/somaxconn so的值
#确保同时提高somaxconn和tcp\u max\u syn\u backlog的值
#为了达到预期的效果。
tcp-backlog 511

#Unix套接字。
#
#指定将用于侦听的Unix套接字的路径
#传入连接。没有默认值，所以Redis不会监听
#在未指定的unix套接字上。
#
# unixsocket /run/redis.sock
# unixsocketperm 700

#客户端空闲N秒后关闭连接（0表示禁用）
timeout 0

#TCP保持连接。
#
#如果不为零，则使用sou KEEPALIVE向缺席的客户端发送TCP ack
#沟通的方式。这有两个原因：
#
#（1）检测死点。
#（2）力网络设备在中间考虑连接
#活着。
#
#在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。
#请注意，要关闭连接，需要两倍的时间。
#在其他内核上，周期取决于内核配置。
#
#此选项的合理值为300秒，这是新的
#Redis默认从Redis 3.2.1开始。
tcp-keepalive 300

################################# TLS/SSL #####################################

#默认情况下，TLS/SSL处于禁用状态。要启用它，“tls端口”配置
#指令可用于定义TLS侦听端口。在上启用TLS
#默认端口，使用：
#
# port 0
# tls-port 6379

#配置X.509证书和私钥以用于验证
#服务器到连接的客户机、主机或群集对等机。这些文件应该
#PEM格式。
#
# tls-cert-file redis.crt
# tls-key-file redis.key
#
#如果密钥文件是使用密码短语加密的，则可以将其包含在此处
#同样如此。
#
# tls-key-file-pass secret

#通常Redis对两个服务器函数使用相同的证书（接受
#连接）和客户端功能（从主机复制，建立
#群集总线连接等）。
#
#有时颁发证书时会使用属性将其指定为
#仅客户端或仅服务器证书。在这种情况下，可能需要使用
#传入（服务器）和传出（客户端）的不同证书
#连接。为此，请使用以下指令：
#
# tls-client-cert-file client.crt
# tls-client-key-file client.key
#
#如果密钥文件是使用密码短语加密的，则可以将其包含在此处
#同样如此。
#
# tls-client-key-file-pass secret

#配置DH参数文件以启用Diffie-Hellman（DH）密钥交换：
#
# tls-dh-params-file redis.dh

#配置CA证书捆绑包或目录以验证TLS/SSL
#客户和同行。Redis需要至少一个
#并且不会隐式使用系统范围的配置。
#
# tls-ca-cert-file ca.crt
# tls-ca-cert-dir /etc/ssl/certs

#默认情况下，TLS端口上的客户端（包括副本服务器）是必需的
#使用有效的客户端证书进行身份验证。
#
#如果指定“否”，则不需要也不接受客户端证书。
#如果指定了“可选”，则接受客户端证书，并且必须
#如果提供，则有效，但不是必需的。
#
# tls-auth-clients no
# tls-auth-clients optional

#默认情况下，Redis副本不会尝试建立TLS连接
#和它的主人。
#
#使用以下指令在复制链接上启用TLS。
#
# tls-replication yes

#默认情况下，Redis集群总线使用纯TCP连接。启用
#TLS对于总线协议，使用以下指令：
#
# tls-cluster yes

#默认情况下，仅启用TLSv1.2和TLSv1.3，强烈建议这样做
#旧的正式弃用版本被禁用以减少攻击面。
#可以显式指定要支持的TLS版本。
#允许的值不区分大小写，包括“TLSv1”、“TLSv1.1”、“TLSv1.2”，
#“TLSv1.3”（OpenSSL>=1.1.1）或任意组合。
#要仅启用TLSv1.2和TLSv1.3，请使用：
#
# tls-protocols "TLSv1.2 TLSv1.3"

#配置允许的密码。有关详细信息，请参阅密码（1ssl）手册页
#关于这个字符串的语法。
#
#注：此配置仅适用于<=TLSv1.2。
#
# tls-ciphers DEFAULT:!MEDIUM

#配置允许的TLSv1.3 CipherSuite。有关更多信息，请参阅密码（1ssl）手册页
#有关此字符串语法的信息，特别是针对TLSv1.3的信息
#密码套装。
#
# tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256

#选择密码时，请使用服务器的首选项而不是客户端
#偏好。默认情况下，服务器遵循客户机的首选项。
#
# tls-prefer-server-ciphers yes

#默认情况下，启用TLS会话缓存以允许更快、更便宜的操作
#由支持它的客户端重新连接。使用以下指令禁用
#缓存。
#
# tls-session-caching no

#更改缓存的默认TLS会话数。零值设置缓存
#大小不限。默认大小为20480。
#
# tls-session-cache-size 5000

#更改缓存TLS会话的默认超时。默认超时为300
#秒。
#
# tls-session-cache-timeout 60

################################# GENERAL (常规)#####################################

#默认情况下，Redis不作为守护进程运行。如果需要，请使用“是”。
#注意，当daemonized时，Redis将在/var/run/Redis.pid中写入一个pid文件。
#当Redis由upstart或systemd监控时，此参数没有影响。
daemonize no

#如果您从upstart或systemd运行Redis，Redis可以与您的
#监督树。选项：
#   supervised no      - 无监督互动
#   supervised upstart - 通过将Redis置于SIGSTOP模式来向upstart发送信号
#                        在upstart作业配置中需要“expect stop”
#   supervised systemd - 通过写入READY=1到$NOTIFY\u插座的信号系统
#                        启动时，并定期更新Redis状态
#                        基础。
#   supervised auto    - 检测upstart或systemd方法基于
#                        UPSTART \u JOB或NOTIFY \u SOCKET环境变量
#注：这些监督方法仅表示“过程准备就绪”
#它们不支持连续ping返回到您的主管。
#
#默认值为“否”。要在upstart/systemd下运行，只需取消注释即可
#下面一行：
#
# supervised auto

#如果指定了pid文件，Redis会在启动时将其写入指定的位置
#在出口处移除。
#
#当服务器运行非守护进程时，如果没有创建pid文件，则不会创建pid文件
#在配置中指定。当服务器被后台监控时，pid文件
#即使未指定也会使用，默认为“/var/run/redis.pid”。
#
#如果Redis无法创建pid文件，那么创建pid文件是最好的选择
#没有什么不好的事情发生，服务器将正常启动和运行。
#
#请注意，在现代Linux系统上“/run/redis.pid”更符合要求
#应该改用。
pidfile /var/run/redis_6379.pid

#指定服务器详细级别。
#这可以是以下情况之一：
# debug (大量信息，对开发/测试有用)
# verbose (许多很少有用的信息，但不像调试级别那样混乱)
# notice (适度冗长，可能是生产中需要的内容)
# warning (只记录非常重要/关键的消息)
loglevel notice

#指定日志文件名。空字符串也可以用来强制
#Redis登录标准输出。请注意，如果您使用标准
#日志输出但是daemonize，日志将被发送到/dev/null
logfile "6379.log"

#要启用到系统记录器的日志记录，只需将“syslog enabled”设置为yes，
#还可以根据需要更新其他syslog参数。
# syslog-enabled no

#指定系统日志标识。
# syslog-ident redis

#指定系统日志工具。必须是USER或介于LOCAL0-LOCAL7之间。
# syslog-facility local0

#禁用内置的崩溃日志，这可能会产生更干净的核心
#当需要转储时，请取消注释以下内容：
#
# crash-log-enabled no

#要禁用作为崩溃日志一部分运行的快速内存检查
#可能会让redis提前终止，请取消注释以下内容：
#
# crash-memcheck-enabled no

#设置数据库数。默认数据库是db0，您可以选择
#在每个连接上使用SELECT<dbid>where创建一个不同的连接
#dbid是介于0和“databases”之间的数字-1
databases 16

#默认情况下，Redis仅在开始登录到
#标准输出，如果标准输出是TTY并且syslog日志记录是
#已禁用。基本上这意味着通常一个标志只显示在
#交互式会话。
#
#但是，可以强制4.0之前的行为并始终显示
#通过将以下选项设置为“是”，可以在启动日志中显示ASCII艺术徽标。
always-show-logo no

#默认情况下，Redis将进程标题（如“top”和“ps”中所示）修改为
#提供一些运行时信息。可以禁用此功能并离开
#通过将以下项设置为“否”执行的进程名称。
set-proc-title yes

#当更改流程标题时，Redis使用以下模板来构造
#修改后的标题。
#
#模板变量在花括号中指定。以下变量是
#支持：
#
# {title}           执行的进程的名称（如果是父进程），或子进程的类型。
# {listen-addr}     绑定地址或“*”后跟TCP或TLS端口侦听，或
#                   如果只有Unix套接字可用。
# {server-mode}     特殊模式，即。"[sentinel]" or "[cluster]".
# {port}            TCP 端口监听 on, or 0.
# {tls-port}        TLS 端口监听on, or 0.
# {unixsocket}      Unix domain socket listening on, or "".
# {config-file}     使用的配置文件的名称。
#
proc-title-template "{title} {listen-addr} {server-mode}"

################################ SNAPSHOTTING (快照) ################################

#将数据库保存到磁盘。
#
#保存<seconds><changes>
#
#如果给定的秒数和给定的
#对数据库执行的写入操作数。
#
#使用一个空字符串参数可以完全禁用快照
#如下例所示：
#
#保存“”
#
#除非另有规定，默认情况下Redis将保存数据库：
#*3600秒（一小时）后，如果至少有一把钥匙发生了变化
#*300秒（5分钟）后，如果至少更改了100个键
#*60秒后，如果至少10000个键发生更改
#
#您可以通过取消以下三行的注释来显式地设置它们。
#
save 900 1
save 300 100
save 60 10000

#默认情况下，如果启用RDB快照，Redis将停止接受写操作
#（至少一个保存点）和最新的后台保存失败。
#这将使用户意识到（以一种困难的方式）数据没有持久化
#在磁盘上正确，否则很可能没有人会注意到和一些
#灾难就会发生。
#
#如果后台保存过程将重新开始工作，Redis将
#自动允许再次写入。
#
#但是，如果您已经设置了对Redis服务器的适当监视
#和持久性，您可能希望禁用此功能，以便Redis
#即使磁盘有问题，也要照常工作，
#权限等。
stop-writes-on-bgsave-error yes

#转储.rdb数据库时使用LZF压缩字符串对象？
#默认情况下，压缩是启用的，因为它几乎总是一个胜利。
#如果您想在保存子进程中保存一些CPU，请将其设置为“否”，但是
#如果有可压缩的值或键，数据集可能会更大。
rdbcompression yes

#由于RDB版本5，CRC64校验和放在文件的末尾。
#这使得格式更能抵抗腐败，但有一个性能
#在保存和加载RDB文件时按需付费（大约10%），因此您可以禁用它
#以获得最佳性能。
#
#在禁用校验和的情况下创建的RDB文件的校验和为零，这将导致
#告诉加载代码跳过检查。
rdbchecksum yes

#启用或禁用ziplist和listpack等的完全检查
#加载RDB或还原有效负载。这减少了断言或
#稍后在处理命令时崩溃。
# 选项:
#   no         - 切勿进行全面检查
#   yes        - 始终保持全面检查
#   clients    - 仅对用户连接执行完全清洁。
#                 排除：RDB文件，从主机接收的还原命令
#                 连接，以及具有
#                 跳过清理负载ACL标志。
#默认值应该是“clients”，但因为它当前影响集群
#通过MIGRATE重新硬化，默认情况下临时设置为“no”。
#
# sanitize-dump-payload no

#将数据库转储到的文件名
dbfilename dump.rdb

#在没有持久性的实例中删除复制使用的RDB文件
#已启用。默认情况下，此选项处于禁用状态，但是存在环境
#对于法规或其他安全问题，RDB文件保留在
#通过主磁盘传送副本，或通过副本存储在磁盘上
#为了加载它们进行初始同步，应该删除
#尽快。请注意，此选项仅适用于同时具有AOF和AOF的实例
#并且RDB持久性被禁用，否则将被完全忽略。
#
#另一种（有时更好）获得相同效果的方法是
#在主实例和副本实例上使用无盘复制。然而
#在副本的情况下，无磁盘并不总是一种选择。
rdb-del-sync-files no

#工作目录。
#
#数据库将被写入这个目录，并指定文件名
#使用“dbfilename”配置指令。
#
#只附加的文件也将在这个目录中创建。
#
#请注意，必须在此处指定目录，而不是文件名。
dir /data

################################# REPLICATION （复制）#################################

#主副本复制。使用replicaof使Redis实例成为
#另一个Redis服务器。关于Redis复制，需要尽快了解的一些事情。
#
#   +------------------+      +---------------+
#   |      Master      | ---> |    Replica    |
#   | (receive writes) |      |  (exact copy) |
#   +------------------+      +---------------+
#
#1）Redis复制是异步的，但是您可以配置一个主机来
#停止接受写入，如果它似乎没有连接到至少
#给定数量的副本。
#2）Redis副本能够与
#如果复制链接丢失的时间相对较少，则为master
#时间。您可能需要配置复制积压工作大小（请参阅下一页）
#此文件的节），根据您的需要使用合理的值。
#3）复制是自动的，不需要用户干预。过了一段时间
#网络分区副本会自动尝试重新连接到主机
#并与它们重新同步。
#
# replicaof 192.168.1.129 6379

#如果主机受密码保护（使用“requirepass”配置
#指令）之前可以告诉复制副本进行身份验证
#正在启动复制同步过程，否则主机将
#拒绝副本请求。
#
# masterauth www362412
#
#但是，如果您使用的是Redis acl（对于Redis版本），这是不够的
#6或更高），并且默认用户不能运行PSYNC
#复制所需的命令和/或其他命令。在这种情况下
#最好配置一个用于复制的特殊用户，并指定
#主用户配置如下：
#
# masteruser <username>
#
#当指定masteruser时，复制副本将根据其
#使用新身份验证窗体的主控形状 AUTH <username> <password>.

#当复制副本失去与主机的连接时，或者当复制
#如果仍在进行中，复制副本可以以两种不同的方式进行操作：
#
#1）如果replica serve stale data设置为“yes”（默认值），则复制副本将
#仍然回复客户端请求，可能包含过期数据，或者
#如果这是第一次同步，数据集可能只是空的。
#
#2）如果replica serve stale data设置为“no”，则replica将用
#除以下命令外，所有命令都出现“正在与主机同步”错误：
#INFO，REPLICAOF，AUTH，PING，SHUTDOWN，REPLCONF，ROLE，CONFIG，SUBSCRIBE，
#取消订阅，PSUBSCRIBE，PUNSUBSCRIBE，发布，PUBSUB，命令，POST，
#主机和延迟。
#
replica-serve-stale-data yes

#您可以将副本实例配置为是否接受写入。反对
#副本实例可能有助于存储一些临时数据（因为
#写在副本上的内容在与主机重新同步后将很容易被删除），但是
#如果客户机因为
#配置错误。
#
#因为redis2.6默认情况下副本是只读的。
#
#注意：只读副本的设计不允许向不受信任的客户端公开
#在互联网上。它只是一个防止实例被滥用的保护层。
#默认情况下，只读副本仍然导出所有管理命令
#例如配置、调试等。在一定程度上你可以提高
#使用“rename command”对所有
#行政/危险命令。
replica-read-only yes

#复制同步策略：磁盘或套接字。
#
#新的复制副本和重新连接无法继续运行的复制副本
#复制过程只是接收差异，需要做什么叫做
#“完全同步”。RDB文件从主机传输到主机
#复制品。
#
#传输有两种不同的方式：
#
# 1) Disk-backed: Redis主机创建一个新进程来写入RDB
                  #磁盘上的文件。稍后，该文件由父级传输
                  #以增量方式处理复制副本。
# 2) Diskless: Redis主机创建一个新进程，直接写入
               #RDB文件到副本套接字，完全不接触磁盘。
#
#使用磁盘备份复制，在生成RDB文件的同时，会生成更多的副本
#只要当前子级
#生成RDB文件完成了它的工作。而是使用无盘复制
#一旦传输开始，到达的新副本将排队等待，新的副本将出现
#传输将在当前传输终止时开始。
#
#当使用无盘复制时，主机将等待一个可配置的时间量
#开始传输前的时间（秒），希望
#副本将到达，传输可以并行化。
#
#使用慢速磁盘和快速（大带宽）网络，无盘复制
#效果更好。
repl-diskless-sync no

#启用无盘复制时，可以配置延迟
#服务器等待生成通过套接字传输RDB的子级
#复制品。
#
#这一点很重要，因为一旦开始转移，就不可能发球
#新副本到达时，将排队等待下一次RDB传输，因此
#服务器等待延迟以便让更多副本到达。
#
#延迟以秒为单位指定，默认为5秒。禁用
#只需将其设置为0秒，传输就会尽快开始。
repl-diskless-sync-delay 5

# -----------------------------------------------------------------------------
#警告：RDB无盘加载是实验性的。因为在这个设置中
#不会立即在磁盘上存储RDB，这可能会导致数据丢失
#故障切换。RDB无盘加载+不处理I/O读取的Redis模块也可能
#如果在初始同步过程中出现I/O错误，会导致Redis中止
#与大师同台演出。只有当你知道你在做什么时才使用。
# -----------------------------------------------------------------------------
#
#复制副本可以加载它从复制链接直接从
#socket，或者将RDB存储到一个文件中，并在该文件完成后读取该文件
#从主人那里收到的。
#
#在许多情况下，磁盘比网络慢，存储和加载速度也慢
#RDB文件可能会增加复制时间（甚至增加主机的
#写时复制内存和缓冲区）。
#但是，直接从套接字解析RDB文件可能意味着
#在创建完整rdb之前刷新当前数据库的内容
#收到。因此，我们有以下选择：
#
# "disabled"    - 不要使用无盘加载（先将rdb文件存储到磁盘）
# "on-empty-db" - 只有在完全安全的情况下才使用无盘加载。
# "swapdb"      - 解析时在RAM中保留当前db内容的副本
                  #数据直接来自套接字。请注意，这需要
                  #足够的内存，如果你没有，你就有被杀的危险。
repl-diskless-load disabled

#副本以预定义的间隔向服务器发送ping。有可能
#使用repl\u ping\u replica\u period选项更改此间隔。默认值
#值为10秒。
#
# repl-ping-replica-period 10

#以下选项设置的复制超时：
#
#1）从副本的角度来看，同步期间的批量传输I/O。
#2）从副本（数据、ping）的角度看主超时。
#3）从主机（REPLCONF ACK pings）的角度来看，复制超时。
#
#确保此值大于
#为复制副本周期指定，否则将检测到超时
#每次主服务器和副本之间的通信量低时。默认值
#值为60秒。
#
# repl-timeout 60

#同步后在副本套接字上禁用TCP\U节点？
#
#如果您选择“是”，Redis将使用较少的TCP数据包和
#将数据发送到副本的带宽更少。但这会增加延迟
#数据将显示在副本端，最多40毫秒
#使用默认配置的Linux内核。
#
#如果您选择“否”，则数据在副本侧出现的延迟将
#但更多的带宽将用于复制。
#
#默认情况下，我们优化低延迟，但在非常高的流量条件下
#或者当主机和复制品有许多跳跃距离时，将此转换为“是”可能会
#这是个好主意。
repl-disable-tcp-nodelay no

#设置复制积压大小。积压工作是一个累积的缓冲区
#当复制副本断开连接一段时间后，复制副本数据
#复制副本想要重新连接，通常不需要完全重新同步，而是需要一个
#部分重新同步就足够了，只需将部分数据传递给复制副本即可
#断开连接时丢失。
#
#复制积压越大，复制副本能够承受的时间就越长
#断开连接，稍后可以执行部分重新同步。
#
#只有在至少连接了一个复制副本时，才会分配积压工作。
#
# repl-backlog-size 1mb

#在主服务器有一段时间没有连接的副本之后，积压的工作将被删除
#释放。以下选项配置所需的秒数
#从最后一个复制副本断开连接时起，对于backlog
#要释放的缓冲区。
#
#请注意，复制副本永远不会为超时释放积压工作，因为它们可能是
#以后升格为硕士，应该能够正确地“部分”
#与其他副本“重新同步”：因此它们应该总是累积积压工作。
#
#值为0表示从不释放积压工作。
#
# repl-backlog-ttl 3600

#副本优先级是Redis在INFO中发布的整数
#输出。Redis Sentinel使用它来选择要升级的副本
#如果主控器不再正常工作，则转换为主控器。
#
#优先级较低的副本被认为更适合升级，因此
#例如，如果有三个优先级为10、100、25 Sentinel的副本
#我会选择优先级为10的，那是最低的。
#
#但是，0的特殊优先级会将复制副本标记为无法执行
#主服务器的角色，因此不会选择优先级为0的副本
#Redis是晋升的哨兵。
#
#默认情况下，优先级为100。
replica-priority 100

# -----------------------------------------------------------------------------
#默认情况下，Redis Sentinel在其报告中包含所有副本。复制品
#可以从Redis Sentinel的公告中排除。未经宣布的复制品
#将被“sentinel replicas<master>”命令忽略，并且不会
#暴露在Redis Sentinel的客户面前。
#
#此选项不会更改副本优先级的行为。即使有
#如果将复制副本设置为“否”，则可以将复制副本升级为主副本。至
#要防止此行为，请将副本优先级设置为0。
#
# replica-announced yes

#如果少于，则主机可以停止接受写入
#N个连接的副本，延迟小于或等于M秒。
#
#N个副本需要处于“联机”状态。
#
#滞后（以秒为单位）必须<=指定值，根据
#从复制副本接收的最后一个ping，通常每秒发送一次。
#
#此选项不保证N个复制副本将接受写入，但
#如果没有足够的副本，将限制丢失写入的曝光窗口
#在指定的秒数内可用。
#
#例如，要要求至少3个延迟<=10秒的副本，请使用：
#
# min-replicas-to-write 3
# min-replicas-max-lag 10
#
# Setting one or the other to 0 disables the feature.
#
# By default min-replicas-to-write is set to 0 (feature disabled) and
# min-replicas-max-lag is set to 10.

#Redis主机可以列出所连接的服务器的地址和端口
#以不同的方式复制。例如，“信息复制”部分
#提供此信息，除其他工具外，由
#Redis Sentinel以发现副本实例。
#此信息可用的另一个地方是
#主人的“角色”命令。
#
#列出的IP地址和端口通常由副本报告
#通过以下方式获得：
#
#   IP: 通过检查对等地址自动检测地址
        #复制副本用于连接主机的套接字的。
#
#   Port: 复制过程中，复制副本与端口通信
          #握手，通常是复制副本用于
          #倾听联系。
#
#然而，当端口转发或网络地址转换（NAT）是
#使用时，实际上可以通过不同的IP和端口访问复制副本
#成对的。复制副本可以使用以下两个选项来
#向其主机报告一组特定的IP和端口，以便
#角色将报告这些值。
#
#如果您只需要重写，则不需要同时使用这两个选项
#端口或IP地址。
#
# replica-announce-ip 5.5.5.5
# replica-announce-port 1234

############################### KEYS TRACKING （键跟踪）#################################

#Redis实现了对客户端缓存值的服务器辅助支持。
#这是使用一个无效表实现的，该表使用
#按密钥名称索引的基数密钥，客户端有哪些密钥。反过来
#它用于向客户端发送失效消息。拜托
#查看此页以了解有关此功能的更多信息：
#
#   https://redis.io/topics/client-side-caching
#
#为客户机启用跟踪时，将假定所有只读查询
#缓存：这将强制Redis在invalidation中存储信息
#桌子。当修改键时，这些信息会被清除，并且
#将失效消息发送到客户端。但是如果工作量
#Redis在很大程度上被读操作所控制，它可以按顺序使用越来越多的内存
#跟踪许多客户机获取的密钥。
#
#因此，可以为
#无效表。默认情况下，它设置为1米的关键点，一旦此限制
#到达时，Redis将开始收回失效表中的键
#即使他们没有被修改，只是为了回收内存：这将反过来
#强制客户端使缓存的值无效。基本上是桌子
#最大大小是要在服务器上花费的内存之间进行权衡
#一边跟踪谁缓存了什么，以及客户端的能力
#在内存中保留缓存对象。
#
#如果将该值设置为0，则表示没有限制，Redis将
#在失效表中保留所需数量的键。
#在“stats”信息部分，您可以找到有关
#在每个给定时刻无效表中的键。
#
#注：在广播模式下使用密钥跟踪时，不使用内存
#所以这个设置是无用的。
#
# tracking-table-max-keys 1000000

################################## SECURITY （安全）###################################

#警告：由于Redis速度非常快，外部用户最多可以尝试
#每秒一百万个密码。这意味着你
#应该使用很强的密码，否则很容易被破解。
#注意，因为密码实际上是客户机之间的共享秘密
#而服务器，不应该被任何人记住，密码
#可以很容易地成为/dev/urandom中的一个长字符串，所以使用
#长而不可使用的密码没有暴力攻击将是可能的。

#Redis ACL用户的定义格式如下：
#
#   user <username> ... acl rules ...
#
#例如：
#
#   user worker +@list +@connection ~jobs:* on >ffa9203c493aa99
#
#特殊用户名“default”用于新连接。如果此用户
#具有“nopass”规则，则新连接将立即通过身份验证
#作为“默认”用户，无需通过
#AUTH命令。否则，如果“default”用户未标记为“nopass”
#连接将在未验证状态下启动，并且需要
#AUTH（或HELLO命令AUTH选项），以便进行身份验证和
#开始工作。
#
#描述用户可以执行的操作的ACL规则如下：
#
#  on           启用用户：可以作为此用户进行身份验证。
#  off          禁用用户：无法再进行身份验证
                #但是，对于此用户，已经通过身份验证的连接
                #仍然有效。
#  skip-sanitize-payload    已跳过还原转储负载。
#  sanitize-payload         还原转储负载已清除（默认）。
#  +<command>   允许执行该命令
#  -<command>   不允许执行该命令
#  +@<category> 允许执行此类类别中的所有命令
                #有效的类别有@admin，@set，@sortedset。。。
                #以此类推，请参阅server.c文件中的完整列表，其中
                #描述并定义了Redis命令表。
                #特殊类别@all表示所有命令，但当前
                #存在于服务器中，并将在将来加载
                #通过模块。
#  +<command>|subcommand    否则允许
                            #已禁用命令。请注意，此表单不是
                            #允许为负，如-DEBUG | SEGFAULT，但是
                            #只有以“+”开头的加法。
#  allcommands  的别名+@all. 注意，它意味着执行的能力
                #通过模块系统加载的所有未来命令。
#  nocommands   的别名-@all.
#  ~<pattern>   添加一个可以作为
                #命令。例如~*允许所有键。模式
                #是一个像钥匙一样的球形图案。
                #可以指定多个模式。
#  allkeys      的别名~*
#  resetkeys    刷新允许的键模式列表。
#  &<pattern>   添加一个全局样式的发布/子频道模式，可以
                #由用户访问。可以指定多个通道
                #模式。
#  allchannels  的别名&amp;*
#  resetchannels            刷新允许的通道模式列表。
#  ><password>  将此密码添加到用户的有效密码列表中。
                #例如，mypass会将“mypass”添加到列表中。
                #此指令清除“nopass”标志（见下文）。
#  <<password>  从有效密码列表中删除此密码。
#  nopass       将删除用户的所有设置密码，并且
                #被标记为不需要密码：这意味着
                #密码将对该用户有效。如果本指令
                #对于默认用户，每个新连接都将
                #立即使用默认用户进行身份验证
                #需要任何显式AUTH命令。注意“resetpass”
                #指令将清除此条件。
#  resetpass    刷新允许的密码列表。而且去掉了
                #“不合格”状态。在“resetpass”之后，用户没有关联的
                #如果不添加密码，就无法进行身份验证
                #一些密码（或者稍后将其设置为“nopass”）。
#  reset        执行以下操作：resetpass、resetkeys、off，
                #               -@all. 用户立即返回到它所处的状态
                #在它诞生之后。
#
#ACL规则可以按任何顺序指定：例如，可以从
#密码、标志或密钥模式。但是请注意，添加剂
#减法规则会根据顺序改变意思。
#例如，请参见以下示例：
#
#   user alice on +@all -DEBUG ~* >somepassword
#
#这将允许“alice”使用除
#调试命令，因为+@all 将所有命令添加到命令集中
#爱丽丝可以用，以后调试被删除了。但是如果我们颠倒顺序
#在两个ACL规则中，结果将不同：
#
#   user alice on -DEBUG +@all ~* >somepassword
#
#现在，当alice在允许的命令集中还没有命令时，DEBUG被删除了
#命令，以后所有的命令都会被添加，这样用户就可以
#执行一切。
#
# Basically ACL rules are processed left-to-right.
#
#有关ACL配置的更多信息，请参阅
#Redis网站https://redis.io/topics/acl

#ACL日志
#
#ACL日志跟踪失败的命令和关联的身份验证事件
#使用ACL。ACL日志有助于对阻止的失败命令进行故障排除
#通过ACL。ACL日志存储在内存中。您可以使用
#ACL日志重置。在下面定义ACL日志的最大条目长度。
acllog-max-len 128

#使用外部ACL文件
#
#可以使用
#仅列出用户的独立文件。这两种方法不能混用：
#如果在此处配置用户，同时激活外部
#ACL文件，服务器将拒绝启动。
#
#外部ACL用户文件的格式与
#redis.conf中用于描述用户的格式。
#
# aclfile /etc/redis/users.acl

#重要提示：从redis6开始，“requirepass”只是一个兼容性问题
#新ACL系统上的层。选项效果将只是设置
#默认用户的密码。客户端仍将使用
#通常使用AUTH<password>或更明确地使用AUTH default<password>
#如果他们遵循新的协议：两者都会起作用。
#
#requirepass与aclfile选项和ACL LOAD不兼容
#命令，这些将导致忽略requirepass。
#
requirepass www362412

#默认情况下，新用户通过
#与此ACL规则“off resetkeys”等效-@all'. 从Redis 6.2开始
#也可以使用ACL规则管理对发布/子频道的访问。这个
#如果新用户由
#acl pubsub default configuration指令，它接受以下值之一：
#
# allchannels: 授予对所有发布/子频道的访问权限
# resetchannels: 撤消对所有发布/子频道的访问
#
#为了在升级Redis 6.0时确保向后兼容性，acl pubsub默认值
#默认为“allchannels”权限。
#
#未来兼容性注意：在Redis的未来版本中
#指令的默认值“allchannels”将在中更改为“resetchannels”
#以提供更好的开箱即用的酒吧/酒吧安全。因此，它是
#建议为所有用户显式定义发布/订阅权限
#而不是依赖于隐含的默认值。一旦设置了显式
#Pub/Sub对于所有现有用户，应该取消对以下行的注释。
#
# acl-pubsub-default resetchannels

#命令重命名（已弃用）。
#
# ------------------------------------------------------------------------
#警告：如果可能，请避免使用此选项。而是使用ACL来删除
#来自默认用户的命令，并将它们仅放在您所使用的某个管理用户中
#为管理目的创建。
# ------------------------------------------------------------------------
#
#可以更改共享文件夹中危险命令的名称
#环境。例如，CONFIG命令可能被重命名为
#很难猜测，所以它仍然可以用于内部使用的工具
#但不适用于一般客户。
#
#示例：
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
#也可以通过将命令重命名为
#空字符串：
#
# rename-command CONFIG ""
#
#请注意，更改登录到
#AOF文件或传输到副本可能会导致问题。

################################### CLIENTS （客户端）####################################

#设置同时连接的最大客户端数。默认情况下
#但是，如果Redis服务器不可用，则此限制设置为10000个客户端
#能够配置进程文件限制以允许指定的限制
#允许的最大客户端数设置为当前文件限制
#减32（因为Redis为内部使用保留了一些文件描述符）。
#
#一旦达到限制，Redis将关闭所有新的发送连接
#“已达到最大客户端数”错误。
#
#重要提示：使用Redis Cluster时，最大连接数也是
#与集群总线共享：集群中的每个节点将使用两个
#连接，一个传入，另一个传出。确定尺寸很重要
#如果集群非常大，则相应限制。
#
# maxclients 10000

############################## MEMORY MANAGEMENT （内存管理）################################

#将内存使用限制设置为指定的字节数。
#当达到内存限制时，Redis将尝试删除密钥
#根据选择的逐出策略（请参阅maxmemory策略）。
#
#如果Redis不能根据策略删除密钥，或者如果策略是
#设置为“noeviction”，Redis将开始用错误回复命令
#这将使用更多的内存，如SET、LPUSH等，并将继续
#回复GET之类的只读命令。
#
#当使用Redis作为LRU或LFU缓存或
#为实例设置硬内存限制（使用“noeviction”策略）。
#
#警告：如果将副本连接到maxmemory打开的实例，
#将减去馈送副本所需的输出缓冲区的大小
#从已用内存计数，以便网络问题/重新同步
#不触发一个循环，其中键被逐出，并依次输出
#复制副本的缓冲区已满，退出的密钥的增量触发删除
#等等，直到数据库完全清空。
#
#总之。。。如果附加了副本，建议您将
#限制maxmemory，以便系统上有一些可用RAM用于复制
#输出缓冲区（但如果策略为“noeviction”，则不需要此缓冲区）。
#
# maxmemory <bytes>

#MAXMEMORY策略：当MAXMEMORY
#到达。您可以从以下行为中选择一种：
#
# volatile-lru -> 使用近似的LRU逐出，仅具有过期集的键。
# allkeys-lru -> 使用近似的LRU逐出任何密钥。
# volatile-lfu -> 使用近似LFU逐出，只使用过期集的键。
# allkeys-lfu -> 使用近似LFU逐出任何键。
# volatile-random -> 删除具有过期集的随机密钥。
# allkeys-random -> 删除随机键，任意键。
# volatile-ttl -> 删除过期时间最近的密钥（次要TTL）
# noeviction -> 不逐出任何内容，只返回一个写操作错误。
#
#LRU表示最近最少使用
#LFU表示使用频率最低
#
#LRU、LFU和volatile-ttl都是用近似方法实现的
#随机算法。
#
#注意：对于上述任何策略，当没有合适的密钥时
#逐出时，Redis将在需要
#更多的记忆。这些命令通常用于创建新键、添加数据或
#修改现有键。例如：SET，INCR，HSET，LPUSH，SUNIONSTORE，
#SORT（由于STORE参数）和EXEC（如果事务包含
#需要内存的命令）。
#
#默认值为：
#
# maxmemory-policy noeviction

#LRU、LFU和最小TTL算法不是精确算法，而是近似算法
#算法（为了节省内存），所以你可以调整它的速度或速度
#准确度。默认情况下，Redis将检查五个键并选择一个是
#最近使用过，您可以使用以下命令更改样本大小
#配置指令。
#
#默认值5会产生足够好的结果。10非常接近
#真正的LRU，但成本更高的CPU。3更快，但不是很准确。
#
# maxmemory-samples 5

#从Redis 5开始，默认情况下，复制副本将忽略其maxmemory设置
#（除非在故障转移后或手动将其升级为主服务器）。意思是
#钥匙的取出将由主人处理，发送
#DEL命令在主端退出密钥时发送到复制副本。
#
#此行为可确保主副本和副本保持一致，并且通常
#但是，如果您的复制副本是可写的，或者您希望复制副本
#有一个不同的内存设置，你确定所有的写入都执行
#如果副本是幂等的，则可以更改此默认值（但请确保
#了解你在做什么）。
#
#请注意，由于复制副本在默认情况下不逐出，因此它可能会使用更多
#内存大于通过maxmemory设置的内存（有某些缓冲区可能
#复制副本上的内存可能更大，或者数据结构有时可能占用更多内存
#等等）。所以一定要监视你的复制品
#有足够的内存，永远不会在
#master点击配置的maxmemory设置。
#
# replica-ignore-maxmemory yes

#Redis通过两种方式回收过期的密钥：当这些密钥被删除时，在访问时
#发现过期了，也在后台，在所谓的
#“活动过期密钥”。键空间被缓慢地交互扫描
#寻找过期的密钥来回收，这样就可以释放内存
#已过期且在短时间内无法再次访问的密钥。
#
#expire循环的默认努力将尝试避免超过
#10%的过期密钥仍在内存中，并将尽量避免使用
#超过总内存的25%并增加系统的延迟。然而
#可以增加通常设置为
#“1”，最大值为“10”。在最大值时
#系统将使用更多的CPU，更长的周期（技术上可能会引入
#更大的延迟），并且将允许更少的已经过期的密钥仍然存在
#在系统中。这是内存、CPU和延迟之间的折衷。
#
# active-expire-effort 1

############################# LAZY FREEING (懒散的自由)####################################

#Redis有两个删除键的原语。一个叫做DEL，是一个blocking
#删除对象。这意味着服务器停止处理新命令
#为了在同步进程中回收与对象相关联的所有内存
#是的。如果删除的键与小对象关联，则所需的时间
#为了执行DEL命令，它非常小，与大多数其他命令相当
#Redis中的O（1）或O（logn）命令。但是，如果密钥与
#包含数百万个元素的聚合值，服务器可以为
#长时间（甚至几秒钟）以完成操作。
#
#基于上述原因，Redis还提供了非阻塞删除原语
#例如UNLINK（non-blocking DEL）和FLUSHALL的ASYNC选项
#FLUSHDB命令，以便在后台回收内存。那些命令
#在固定时间内执行。另一个线程将逐渐释放
#尽可能快地在背景中创建对象。
#
#FLUSHDB和FLUSHDB的DEL、UNLINK和ASYNC选项由用户控制。
#应用程序的设计决定了什么时候是一个好的应用程序
#使用其中一个的想法。但是Redis服务器有时不得不
#删除键或刷新整个数据库作为其他操作的副作用。
#具体来说，Redis独立于数据库中的用户调用删除对象
#以下场景：
#
#1）逐出时，由于maxmemory和maxmemory策略配置，
#为了给新的数据腾出空间，而不超过指定的
#内存限制。
#2）因为过期：当一个密钥与一个相关联的生存时间（参见
#EXPIRE命令）必须从内存中删除。
#3）由于在键上存储数据的命令的副作用
#已经存在。例如，RENAME命令可以删除旧密钥
#当内容被另一个内容替换时。类似SUNIONSTORE
#或使用存储选项排序可能会删除现有密钥。SET命令
#它本身删除指定键的任何旧内容以便替换
#它使用指定的字符串。
#4）在复制期间，当复制副本与执行完全重新同步时
#它的主人，整个数据库的内容被删除，以便
#加载刚传输的RDB文件。
#
#在上述所有情况下，默认情况是以阻塞方式删除对象，
#好像戴尔被叫来了。但是，您可以具体配置每个案例
#以一种非阻塞的方式释放内存，就像取消链接一样
#使用以下配置指令调用。

lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

#在替换用户代码DEL调用的情况下，这也是可能的
#使用UNLINK调用并不容易，要修改DEL的默认行为
#命令的行为完全类似于取消链接，使用以下配置
#指令：

lazyfree-lazy-user-del no

#FLUSHDB、FLUSH和SCRIPT FLUSH都支持异步和同步
#删除，可以通过将[SYNC | ASYNC]标志传递到
#命令。当两个标志都未传递时，此指令将用于确定
#如果数据应该异步删除。

lazyfree-lazy-user-flush no

################################ THREADED I/O (线程I/O)#################################

#Redis主要是单线程的，但是也有一些特定的线程
#诸如取消链接、缓慢的I/O访问等操作
#在侧螺纹上执行。
#
#现在还可以处理Redis客户机套接字读写
#在不同的I/O线程中。因为通常情况下，写作速度很慢
#Redis用户使用流水线来提高Redis的性能
#核心，并产生多个实例，以扩大规模。使用I/O
#线程可以轻松地将Redis的速度提高两倍，而无需重新调用
#对实例进行流水线或切分。
#
#默认情况下，线程是禁用的，我们建议只在机器中启用它
#至少有4个或更多的核心，留下至少一个备用核心。
#使用8个以上的线程不太可能有多大帮助。我们还建议使用
#只有在Redis出现性能问题时才使用线程I/O
#实例能够使用相当大比例的CPU时间，否则
#使用此功能没有意义。
#
#例如，如果你有一个四核的盒子，试着使用2或3个I/O
#线程，如果你有一个8核，尝试使用6线程。为了
#使用以下配置指令启用I/O线程：
#
# io-threads 4
#
#将io threads设置为1只会像往常一样使用主线程。
#当I/O线程被启用时，我们只使用线程进行写操作，也就是说
#执行write（2）syscall并将客户机缓冲区传输到
#插座。但是，也可以启用读写线程
#协议解析使用以下配置指令，通过设置
#是的：
#
# io-threads-do-reads no
#
#通常线程读取并没有多大帮助。
#
#注1：此配置指令在运行时不能通过
#配置集。Aso当SSL被禁用时，此功能当前不起作用
#已启用。
#
#注2：如果您想使用Redis基准测试Redis加速，请
#当然，您还可以使用
#--threads选项来匹配Redis线程的数量，否则您将无法
#能够注意到改进。

############################ KERNEL OOM CONTROL (内核OOM控件)##############################

#在Linux上，可以向内核提示什么进程
#当内存不足时，应该先终止。
#
#启用此功能可使Redis主动控制oom\u score\u adj值
#对于它的所有进程，取决于它们的角色。默认分数将
#尝试先杀死后台子进程，然后
#复制品在主人面前被杀死。
#
#Redis支持三个选项：
#
# no:       不更改oom score adj（默认值）。
# yes:      “相对”的别名见下文。
# absolute: oom score adj值中的值按原样写入内核。
# relative: 在下列情况下，值相对于oom_score_adj的初始值使用
            #服务器启动，然后被钳制在-1000到1000的范围内。
            #因为初始值通常为0，所以它们通常与
            #绝对值。
oom-score-adj no

#使用oom score adj时，此指令控制使用的特定值
#对于主进程、副本进程和后台子进程。数值范围为-2000到
#2000（更高意味着更有可能被杀）。
#
#非特权进程（不是根进程，也没有CAP\u SYS\u资源功能）
#可以自由地增加它们的价值，但不能将其降低到初始值以下
#设置。这意味着将oom score adj设置为“relative”，并将
#oom score将值调整为正值总是成功的。
oom-score-adj-values 0 200 800


#################### 内核透明hugepage控件 ######################

#通常，内核透明的大页面控件设置为“madvise”或
#或者默认为“从不”（/sys/kernel/mm/transparent\u hugepage/enabled），其中
#以防此配置无效。在其设置为“始终”的系统上，
#redis将尝试专门为redis进程禁用它
#为了避免延迟问题，特别是fork（2）和CoW。
#如果出于某种原因，您希望保持启用状态，可以将此配置设置为
#“no”和内核全局设置为“always”。

disable-thp yes

############################## APPEND ONLY MODE (AOF模式)###############################

#默认情况下，Redis将数据集异步转储到磁盘上。此模式为
#在许多应用程序中已经足够好了，但是Redis进程或
#断电可能会导致几分钟的写操作丢失（取决于
#配置的保存点）。
#
#仅附加文件是一种提供
#更好的耐用性。例如，使用默认数据fsync策略
#（请参阅后面的配置文件）Redis在一段时间内只会丢失一秒钟的写操作
#戏剧性的事件，比如服务器断电，或者某个事件发生时的一次写入
#Redis进程本身出错，但操作系统是错误的
#仍然正常运行。
#
#AOF和RDB持久性可以同时启用而不会出现问题。
#如果启动时启用了AOF，Redis将加载AOF，即文件
#具有更好的耐久性保证。
#
#请检查https://redis.io/topics/persistence 更多信息。

appendonly no

#仅附加文件的名称（默认值：“appendonly.aof”）

appendfilename "appendonly.aof"

#fsync（）调用告诉操作系统在磁盘上实际写入数据
#而不是在输出缓冲区中等待更多的数据。有些操作系统会很流行
#磁盘上的数据，其他一些操作系统会尽快尝试这样做。
#
#Redis支持三种不同的模式：
#
# no: 不要fsync，只要让操作系统在需要时刷新数据即可。更快。
# always: 每次写入仅附加日志后进行fsync。慢，最安全。
# everysec: 每秒只同步一次。妥协。
#
#默认值是“everysec”，因为这通常是
#速度和数据安全。这取决于你是否能放松一下
#“no”将允许操作系统在
#它想要更好的表演（但是如果你能接受
#某些数据丢失考虑默认的持久模式（SNAP），
#或者相反，使用“总是”这是非常缓慢，但有点安全比
#埃弗里塞克。
#
#更多详情请查看以下文章：
# http://antirez.com/post/redis-persistence-demystified.html
#
#如果不确定，请使用“everysec”。

# appendfsync always
appendfsync everysec
# appendfsync no

#当AOF fsync策略设置为always或everysec时，背景
#保存过程（后台保存或AOF日志后台重写）是
#在某些Linux配置中，对磁盘执行大量I/O操作
#Redis可能在fsync（）调用上阻塞太长。请注意，没有修复
#目前，这是因为即使在不同的线程中执行fsync也会阻塞
#我们的同步写入（2）调用。
#
#为了缓解这个问题，可以使用以下选项
#这将防止在主进程中调用fsync（），而
#正在进行BGSAVE或BGREWRITEAOF。
#
#这意味着，当另一个孩子在存钱时，Redis的耐用性就变了
#与“appendfsync none”相同。实际上，这意味着
#在最坏的情况下（使用
#默认Linux设置）。
#
#如果您有延迟问题，请将此设置为“是”。否则就留着吧
#从耐用性的角度来看，“不”是最安全的选择。

no-appendfsync-on-rewrite no

#自动重写仅附加的文件。
#Redis能够自动重写隐式调用的日志文件
#当AOF日志大小按指定的百分比增长时，BGREWRITEAOF。
#
#这就是它的工作原理：Redis会记住
#最新重写（如果重新启动后没有发生重写，则
#使用启动时的AOF）。
#
#此基本大小与当前大小进行比较。如果当前大小为
#大于指定的百分比时，将触发重写。阿尔索
#您需要为要重写的AOF文件指定最小大小，如下所示
#有助于避免重写AOF文件，即使百分比增加
#但它仍然很小。
#
#指定0的百分比以禁用自动AOF
#重写功能。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

#在Redis过程中，可能会发现AOF文件在末尾被截断
#启动过程，当AOF数据被加载回内存时。
#这可能发生在运行Redis的系统中
#崩溃，尤其是在没有
#data=ordered选项（但是当Redis本身
#崩溃或中止，但操作系统仍正常工作）。
#
#Redis可以在出现错误时退出，也可以加载尽可能多的数据
#如果找到AOF文件，则启动
#最后被截断。以下选项控制此行为。
#
#如果aof load truncated设置为yes，则加载并删除一个截断的aof文件
#Redis服务器开始发出一个日志来通知用户该事件。
#否则，如果该选项设置为“否”，则服务器将中止并返回一个错误
#拒绝开始。当选项设置为“否”时，用户需要
#在重新启动之前，使用“redis check AOF”实用程序修复AOF文件
#服务器。
#
#请注意，如果发现AOF文件在中间被损坏
#服务器仍将退出并出现错误。此选项仅适用于
#Redis将尝试从AOF文件中读取更多数据，但字节不足
#会被发现的。
aof-load-truncated yes

#当重写AOF文件时，Redis能够在
#AOF文件，用于更快的重写和恢复。启用此选项时
#重写的AOF文件由两个不同的节组成：
#
#[RDB文件][AOF tail]
#
#加载时，Redis识别出AOF文件以“Redis”开头
#字符串并加载带前缀的RDB文件，然后继续加载AOF
#尾巴。
aof-use-rdb-preamble yes

################################ LUA SCRIPTING (LUA脚本) ###############################

#Lua脚本的最大执行时间（毫秒）。
#
#如果达到最长执行时间，Redis将记录脚本正在运行
#在允许的最长时间后仍在执行，并将开始
#答复有错误的查询。
#
#当长时间运行的脚本超过最大执行时间时，只有
#脚本KILL和SHUTDOWN NOSAVE命令可用。第一个可以是
#用于停止尚未调用任何写入命令的脚本。第二个
#是在执行写入命令时关闭服务器的唯一方法
#已由脚本发出，但用户不想等待
#脚本的终止。
#
#将其设置为0或负值，以便在没有警告的情况下无限执行。
lua-time-limit 5000

################################ REDIS CLUSTER  (REDIS集群)###############################

#普通Redis实例不能是Redis集群的一部分；仅限于
#以群集节点可以启动的方式启动。为了启动一个Redis实例作为
#群集节点启用群集支持取消注释以下内容：
#
# cluster-enabled yes

#每个集群节点都有一个集群配置文件。此文件不可用
#打算手工编辑的。它由Redis节点创建和更新。
#每个Redis集群节点都需要不同的集群配置文件。
#确保在同一系统中运行的实例没有
#重叠的群集配置文件名。
#
# cluster-config-file nodes-6379.conf

#Cluster node timeout是节点必须无法访问的毫秒数
#在失效状态下考虑。
#大多数其他内部时间限制是节点超时的倍数。
#
# cluster-node-timeout 15000

#如果发生故障的主机的复制副本的数据
#看起来太老了。
#
#对于一个复制品来说，没有一种简单的方法能够真正精确地测量
#它的“数据时代”，因此执行以下两项检查：
#
#1）如果有多个副本可以进行故障切换，它们将交换消息
#为了给复制品以最好的优势
#复制偏移量（处理来自主服务器的更多数据）。
#复制副本将尝试通过偏移量获得它们的排名，并应用到起始位置
#故障转移的延迟与它们的等级成比例。
#
#2）每个副本计算最后一次与
#它的主人。这可以是最后收到的ping或命令（如果主机
#仍处于“已连接”状态），或自
#与主机断开连接（如果复制链路当前已关闭）。
#如果上一次交互太旧，复制副本将不会尝试故障转移
#完全没有。
#
#点“2”可由用户调整。特别是复制副本将不执行
#如果自上次与主机交互后，故障转移
#已用时间大于：
#
#   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period
#
#例如，如果节点超时为30秒，那么集群副本有效性系数
#为10，并且假设默认的repl-ping复制周期为10秒，则
#如果复制副本无法与主机通信，则它不会尝试故障转移
#超过310秒。
#
#较大的群集副本有效性系数可能会使数据太旧的副本无法进行故障切换
#一个主节点，而太小的值可能会阻止集群
#选择一个复制品。
#
#为了获得最大可用性，可以设置集群副本有效性因子
#值为0，这意味着复制副本将始终尝试故障转移
#不管他们最后一次和师父互动。
#（然而，他们总是尝试应用一个与他们的时间成比例的延迟
#偏移秩）。
#
#零是唯一能够保证当所有分区都恢复时
#群集将始终能够继续。
#
# cluster-replica-validity-factor 10

#群集副本能够迁移到孤立的主服务器，即主服务器
#没有工作副本。这提高了集群能力
#抵抗失败，否则一个孤立的主人就不能被故障转移
#如果没有工作副本，则会发生故障。
#
#仅当仍有至少一个副本时，副本才会迁移到孤立的主副本
#给他们的老主人其他工作副本的数量。这个号码
#是“移民壁垒”。迁移屏障为1意味着复制副本
#仅当其主服务器至少有一个其他工作副本时，才会进行迁移
#等等。它通常反映您希望为每个
#你群里的主人。
#
#默认值为1（复制副本仅在其主副本保留至少
#一个副本）。要禁用迁移，只需将其设置为非常大的值或
#将群集允许副本迁移设置为“否”。
#可以设置值0，但仅对调试和安装有用
#在生产中。
#
# cluster-migration-barrier 1

#关闭此选项允许使用较少的自动群集配置。
#它既禁用了到孤立主服务器的迁移，也禁用了从主服务器的迁移
#它变成了空的。
#
#默认值为“是”（允许自动迁移）。
#
# cluster-allow-replica-migration yes

#默认情况下，Redis集群节点在检测到查询时停止接受查询
#至少有一个哈希槽未覆盖（没有可用的节点为其提供服务）。
#如果集群部分关闭（例如一系列哈希槽），则使用这种方法
#不再覆盖）所有集群最终都变得不可用。
#一旦所有插槽被覆盖，它就会自动返回可用状态。
#
#但是有时你需要集群的子集，
#继续接受对仍然存在的密钥空间部分的查询
#覆盖。为此，只需将集群设置为需要完全覆盖
#选择否。
#
# cluster-require-full-coverage yes

#此选项设置为“是”时，可防止复制副本尝试故障转移
#主设备故障时的主设备。但是，复制副本仍然可以执行
#手动故障切换（如果强制执行）。
#
#这在不同的场景中非常有用，尤其是在多个场景中
#数据中心运营，我们希望一方永远不会得到提升
#在完全直流故障的情况下。
#
# cluster-replica-no-failover no

#当设置为yes时，此选项允许节点在
#集群处于关闭状态，只要它相信自己拥有这些插槽。
#
#这对于两种情况很有用。第一种情况是申请
#在节点故障或网络分区期间不需要数据的一致性。
#这方面的一个例子是缓存，只要节点拥有数据，它就可以访问缓存
#应该可以为它服务。
#
#第二个用例适用于不符合推荐标准的配置
#三个碎片，但要启用群集模式和规模以后。A.
#1或2分片配置中的主中断会导致读/写中断
#如果不设置此选项，则整个集群只有一次写中断。
#如果没有法定人数的主机，插槽所有权将不会自动更改。
#
# cluster-allow-reads-when-down no

#为了设置集群，请务必阅读文档
#可在https://redis.io web 地点。

########################## CLUSTER DOCKER/NAT support (集群DOCKER/NAT支持) ########################

#在某些部署中，Redis集群节点地址发现失败，因为
#地址被NAT-ted或者因为端口被转发（典型的情况是
#码头工人和其他集装箱）。
#
#为了使Redis集群能够在这样的环境中工作，一个静态的
#每个节点都知道需要其公共地址的配置。这个
#此范围使用以下四个选项：
#
# * cluster-announce-ip
# * cluster-announce-port
# * cluster-announce-tls-port
# * cluster-announce-bus-port
#
#每个都向节点指示其地址、客户端端口（用于连接）
#没有和有TLS）和群集消息总线端口。信息是
#在总线数据包的报头中发布，以便其他节点能够
#正确映射发布信息的节点的地址。
#
#如果cluster tls设置为yes并且cluster announce tls port被省略或设置
#设置为零，则cluster announce port表示TLS端口。还要注意的是
#如果cluster tls设置为no，则cluster announce tls port无效。
#
#如果不使用上述选项，则正常的Redis集群自动检测
#将改为使用。
#
#请注意，重新映射时，总线端口可能不在
#客户端端口+10000，因此您可以根据需要指定任何端口和总线端口
#他们是如何被重新映射的。如果未设置总线端口，则
#10000美元将照常使用。
#
#示例：
#
# cluster-announce-ip 10.1.1.5
# cluster-announce-tls-port 6379
# cluster-announce-port 0
# cluster-announce-bus-port 6380

################################## SLOW LOG (慢对数)###################################

#Redis Slow Log是一个系统，用于记录超过指定时间的查询
#执行时间。执行时间不包括I/O操作
#比如和客户交谈，发送回复等等，
#但实际执行命令所需的时间（这是唯一的
#命令执行的一个阶段，线程被阻塞而不能服务
#其他请求）。
#
#您可以用两个参数配置慢日志：一个参数告诉Redis
#以微秒为单位的执行时间是多少
#命令，另一个参数是
#慢日志。记录新命令时，最旧的命令将从
#记录的命令队列。
#以下时间以微秒表示，因此1000000是等效的
#到一秒钟。请注意，负数将禁用慢速日志，而
#值为零将强制记录每个命令。
slowlog-log-slower-than 10000

#这个长度没有限制。只是要注意它会消耗内存。
#您可以通过SLOWLOG RESET回收慢日志使用的内存。
slowlog-max-len 128

################################ LATENCY MONITOR (自动监护仪)##############################

#Redis延迟监控子系统对不同的操作进行采样
#在运行时收集与可能的数据源相关的数据
#Redis实例的延迟。
#
#通过LATENCY命令，用户可以获得这些信息
#打印图表并获取报告。
#
#系统只记录在相同或相同时间内执行的操作
#大于通过指定的毫秒数
#延迟监视器阈值配置指令。当其值设置为
#如果设置为零，则延迟监视器将关闭。
#
#默认情况下，延迟监视是禁用的，因为它通常不需要
#如果您没有延迟问题，那么收集数据就有了性能
#冲击虽然很小，但可以在大载荷下测量。延迟
#可以在运行时使用命令轻松地启用监视
#“配置设置延迟监视器阈值<毫秒>”如果需要。
latency-monitor-threshold 0

############################# EVENT NOTIFICATION (事件通知)##############################

#Redis可以将密钥空间中发生的事件通知Pub/Sub客户机。
#此功能记录在https://redis.io/topics/notifications
#
#例如，如果启用了keyspace事件通知
#对存储在数据库0、2中的键“foo”执行DEL操作
#消息将通过发布/订阅发布：
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
#可以在一个集合中选择Redis将通知的事件
#班级人数。每个类都由一个字符标识：
#
#  K     按键空间事件，以“\u Keyspace@<db>”前缀发布。
#  E     Keyevent事件，以“\u Keyevent@<db>”前缀发布。
#  g     通用命令（非特定类型），如DEL、EXPIRE、RENAME等。。。
#  $     String 命令
#  l     List 命令
#  s     Set 命令
#  h     Hash 命令
#  z     Sorted set 命令
#  x     过期事件（每次密钥过期时生成的事件）
#  e     逐出事件（为maxmemory逐出键时生成的事件）
#  t     Stream 命令
#  d     模块键类型事件
#  m     关键未命中事件（注：不包括在“A”类中）
#  A     g$lshzxetd的别名，因此“AKE”字符串表示所有事件
         #（因其特殊性而被排除在“A”之外的关键未命中事件除外）
         #独特的性质）。
#
#“notify keyspace events”将一个由
#零个或多个字符的。空字符串表示通知
#已禁用。
#
#示例：从
#事件名称，使用：
#
#  notify-keyspace-events Elg
#
#示例2：获取订阅通道的过期密钥流
#姓名__keyevent@0__：过期使用：
#
#  notify-keyspace-events Ex
#
#默认情况下，所有通知都被禁用，因为大多数用户不需要
#此功能和该功能有一些开销。注意，如果你不
#指定K或E中的至少一个，则不会传递任何事件。
notify-keyspace-events ""

############################### GOPHER SERVER (GOPHER服务器)#################################

#Redis包含Gopher协议的实现，如中所述
#RFC 1436(https://www.ietf.org/rfc/rfc1436.txt).
#
#地鼠协议在90年代末非常流行。这是另一种选择
#而服务器端和客户端的实现都非常简单
#Redis服务器只有100行代码来实现这一点
#支持。
#
#你现在对地鼠做什么？好吧，戈弗从来没有死过，而且
#最近有一个运动，以使地鼠更层次的内容
#由纯文本文件组成的。有些人想要更简单的
#互联网，也有人认为主流互联网变得太多了
#控制，为那些
#想呼吸点新鲜空气。
#
#无论如何，在Redis的10岁生日那天，我们给了它Gopher协议
#作为礼物。
#
#---它是如何工作的---
#
#Redis Gopher支持使用Redis的内联协议
#两种内联请求无论如何都是非法的：一个空请求
#或者任何以“/”开头的请求（没有开始的Redis命令）
#用这样的斜杠）。正常的RESP2/RESP3请求完全超出
#Gopher协议实现的路径和服务也照常进行。
#
#如果您在启用Gopher时打开到Redis的连接并发送它
#类似于“/foo”的字符串，如果有一个名为“/foo”的键，则通过
#地鼠协议。
#
#为了创造一个真正的地鼠“洞”（地鼠在地鼠网站的名称）
#你可能需要一个如下的脚本：
#
#   https://github.com/antirez/gopher2redis
#
#---安全警告---
#
#如果你打算把Redis放在一个可以公开访问的地址
#要访问服务器Gopher页面，请确保为实例设置密码。
#设置密码后：
#
#1.Gopher服务器（启用时，不是默认情况下）仍将提供服务
#内容通过Gopher。
#2.但是在客户端调用之前不能调用其他命令
#验证。
#
#所以使用'requirepass'选项来保护您的实例。
#
#请注意，当“io线程执行读取”时，当前不支持Gopher
#已启用。
#
#要启用Gopher支持，请取消对以下行的注释并设置选项
#从“否”（默认值）到“是”。
#
# gopher-enabled no

############################### ADVANCED CONFIG （高级配置）###############################

#当哈希值具有
#少量条目，且最大条目不超过给定值
#门槛。可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

#列表也以一种特殊的方式编码以节省大量空间。
#可以指定每个内部列表节点允许的条目数
#作为一个固定的最大尺寸或元素的最大数量。
#对于固定的最大大小，使用-5到-1，意思是：
# -5: max size: 64 Kb  <-- 不建议用于正常工作负载
# -4: max size: 32 Kb  <-- 未推荐的
# -3: max size: 16 Kb  <-- 可能不推荐
# -2: max size: 8 Kb   <-- 很好
# -1: max size: 4 Kb   <-- 很好
#正数表示存储的元素数正好等于
#每个列表节点。
#最高性能的选项通常是-2（8KB大小）或-1（4KB大小），
#但是如果您的用例是唯一的，则根据需要调整设置。
list-max-ziplist-size -2

#列表也可以被压缩。
#Compress depth是的*每*边的quicklist ziplist节点数
#要从压缩中*排除*的列表。名单的头尾
#对于快速的push/pop操作总是解压缩的。设置为：
# 0: 禁用所有列表压缩
# 1: 深度1表示“在列表中的1个节点之后才开始压缩，
     #“从头部或尾部”
     #所以：[头]->节点->节点->…->节点->[尾]
     #[头]，[尾]将始终未压缩；内部节点将压缩。
# 2: [head]->[next]->节点->节点->…->节点->[prev]->[tail]
     #这里的意思是：不要压缩头部或头部->下一个或尾部->上一个或尾部，
     #但是压缩它们之间的所有节点。
# 3: [head]->[next]->[next]->节点->节点->…->节点->[prev]->[prev]->[tail]
     #等等。
list-compress-depth 0

#集合只有一种特殊的编码方式：当集合被合成时
#刚好是以10为基数的整数的字符串
#64位有符号整数。
#下面的配置设置设置了
#设置以使用此特殊的内存节省编码。
set-max-intset-entries 512

#与哈希和列表类似，排序集也在
#为了节省很多空间。此编码仅在长度和
#排序集的元素低于以下限制：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

#HyperLogLog稀疏表示字节数限制。限制包括
#16字节头。当使用稀疏表示的HyperLogLog交叉时
#这个极限，就转化为稠密表示。
#
#大于16000的值是完全无用的，因为此时
#密集表示更高效。
#
#建议值为~3000，以便获得
#节省空间的编码，而不会减慢太多的PFADD，
#这是O（N）与稀疏编码。值可以提高到
#当CPU不是问题，但空间是问题，数据集是
#由许多基数在0-15000范围内的超对数组成。
hll-sparse-max-bytes 3000

#流宏节点最大大小/项。流数据结构是一个基数
#对内部多个项目进行编码的大节点树。使用此配置
#可以配置单个节点的字节大小，以及
#在切换到新节点之前它可能包含的最大项目数
#追加新的流条目。如果以下任何设置设置为
#零，则忽略限制，因此可以仅设置一个
#通过将max bytes设置为0并将max entries设置为所需的值来限制max entries
#价值观。
stream-node-max-bytes 4096
stream-node-max-entries 100

#主动重灰化在中每100毫秒CPU时间使用1毫秒
#以帮助重新灰化主Redis哈希表（映射顶级
#值的键）。Redis使用的哈希表实现（参见dict.c）
#执行延迟重哈希：在哈希表中运行的操作越多
#即重新灰化，执行的重新灰化“步骤”越多，因此如果
#服务器处于空闲状态，重新灰化从未完成，并且使用了更多内存
#通过哈希表。
#
#默认值是每秒使用10次此毫秒，以便
#积极更新主要词典，尽可能释放内存。
#
#如果不确定：
#如果您有严格的延迟要求，那么请使用“activerehashing no”
#在您的环境中，Redis可以不时地进行回复并不是一件好事
#延迟2毫秒的查询。
#
#如果你没有这样严格的要求，那么使用“activerehashing yes”
#希望尽快释放内存。
activerehashing yes

#客户端输出缓冲区限制可用于强制断开客户端连接
#由于某种原因，从服务器读取数据的速度不够快（a
#常见的原因是Pub/Sub客户机不能像
#出版商可以制作它们）。
#
#对于三种不同类型的客户端，可以设置不同的限制：
#
# normal -> 普通客户端包括监控客户端
# replica  -> 复制客户端
# pubsub -> 客户端订阅了至少一个子频道或模式
#
#每个客户端输出缓冲区限制指令的语法如下：
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
#一旦达到硬限制，或者
#已达到软限制，并且在指定数量的
#秒（连续）。
#例如，如果硬限制是32兆字节，软限制是
#16兆字节/10秒，客户端将立即断开连接
#如果输出缓冲区的大小达到32兆字节，还将得到
#如果客户端达到16兆字节并持续克服
#限制为10秒。
#
#默认情况下，普通客户端不受限制，因为它们不接收数据
#不用问（以推的方式），但只是在一个请求之后，所以只有
#异步客户机可能会创建一个更快请求数据的场景
#比它能读的还多。
#
#相反，pubsub和replica客户端有一个默认限制，因为
#订户和副本以推送方式接收数据。
#
#硬限制或软限制都可以通过将其设置为零来禁用。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

#客户端查询缓冲区积累新命令。它们仅限于一个固定的
#为避免协议失步（例如
#实例中的错误）将导致中的未绑定内存使用
#查询缓冲区。但是，如果您有非常特殊的
#我们需要大量的multi/exec请求或类似的请求。
#
# client-query-buffer-limit 1gb

#在Redis协议中，批量请求，即表示单个
#字符串，通常限制为512 mb。但是，您可以更改此限制
#在这里，但必须是1mb或更大
#
# proto-max-bulk-len 512mb

#Redis调用一个内部函数来执行许多后台任务，比如
#在超时时关闭客户端连接，清除过期的
#从未要求过，等等。
#
#不是所有的任务都以相同的频率执行，但是Redis检查
#根据指定的“hz”值执行的任务。
#
#默认情况下“hz”设置为10。当
#Redis是空闲的，但同时会使Redis在
#有许多密钥同时过期，并且可能会出现超时
#更精确地处理。
#
#范围在1到500之间，但是超过100的值通常不是
#好主意。大多数用户应该使用默认值10，并将其提高到10
#100只适用于要求非常低延迟的环境。
hz 10

#通常，有一个与频率成比例的HZ值是有用的
#连接的客户端数。例如，这有助于
#避免每次后台任务调用都处理过多的客户端
#为了避免延迟峰值。
#
#由于默认的HZ值被保守地设置为10，Redis
#提供并默认启用使用自适应HZ值的功能
#当有许多连接的客户机时，将临时引发。
#
#启用动态HZ时，将使用实际配置的HZ
#作为基线，但配置的HZ值的倍数实际上是
#一旦连接了更多客户端，就可以根据需要使用。就这样一个懒汉
#实例将使用很少的CPU时间，而繁忙的实例将
#反应更快。
dynamic-hz yes

#当子级重写AOF文件时，如果启用了以下选项
#文件将每生成32MB的数据进行一次fsync。这很有用
#为了更增量地将文件提交到磁盘并避免
#大延迟峰值。
aof-rewrite-incremental-fsync yes

#redis保存RDB文件时，如果启用了以下选项
#文件将每生成32MB的数据进行一次fsync。这很有用
#为了更增量地将文件提交到磁盘并避免
#大延迟峰值。
rdb-save-incremental-fsync yes

#Redis LFU逐出（参见maxmemory设置）可以进行调优。不过，这是一个好主意
#从默认设置开始，只在调查之后更改它们
#如何提高性能以及LFU键如何随时间变化，这是什么
#可以通过OBJECT FREQ命令进行检查。
#
#Redis LFU实现中有两个可调参数：
#计数器对数因子和计数器衰减时间。重要的是
#在更改这两个参数之前，请先了解它们的含义。
#
#LFU计数器每个键只有8位，它的最大值是255，所以Redis
#使用具有对数行为的概率增量。给定值
#在旧计数器中，当访问一个键时，计数器以
#这样：
#
#1.提取0到1之间的随机数R。
#2.概率P的计算公式为1/（旧值*lfu对数系数+1）。
#3.只有当R<P时，计数器才递增。
#
#默认的lfu对数因子是10。这是一个频率
#计数器会随着不同访问次数的不同而变化
#对数因子：
#
# +--------+------------+------------+------------+------------+------------+
# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
# +--------+------------+------------+------------+------------+------------+
# | 0      | 104        | 255        | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 1      | 18         | 49         | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 10     | 10         | 18         | 142        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 100    | 8          | 11         | 49         | 143        | 255        |
# +--------+------------+------------+------------+------------+------------+
#
#注：上表是通过运行以下命令获得的：
#
#   redis-benchmark -n 1000000 incr foo
#   redis-cli object freq foo
#
#注2：计数器初始值为5，以便给新对象一个机会
#积累命中率。
#
#计数器衰减时间是按顺序必须经过的时间（以分钟为单位）
#将键计数器除以2（如果它有值，则递减）
#小于等于10）。
#
#lfu衰减时间的默认值为1。特殊值0表示
#每次扫描计数器时，都会损坏它。
#
# lfu-log-factor 10
# lfu-decay-time 1

########################### ACTIVE DEFRAGMENTATION (活动碎片整理)#######################
#
#什么是活动碎片整理？
# -------------------------------
#
#主动（在线）碎片整理允许Redis服务器压缩
#内存中数据的小分配和释放之间的剩余空间，
#从而允许回收内存。
#
#碎片化是每个分配器（但是
#幸运的是，对于Jemalloc）和某些工作负载，情况就不是这样了。通常是服务器
#需要重新启动以降低碎片，或者至少刷新碎片
#删除所有数据并重新创建。不过，多亏了这个功能
#由Oran Agra for Redis 4.0实现这个过程可以在运行时发生
#在服务器运行时以“热”方式。
#
#基本上当碎片超过某个级别时（参见
#配置选项）Redis将开始创建
#通过利用特定的Jemalloc在连续内存区域中获取值
#特性（以便了解分配是否导致碎片
#并将其分配到一个更好的地方），同时，将释放
#数据的旧拷贝。这个过程，对所有的键都是递增的
#将导致碎片降回正常值。
#
#需要了解的重要事项：
#
#1.此功能默认禁用，只有编译Redis时才有效
#为了使用Jemalloc的副本，我们附带了Redis的源代码。
#这是Linux版本的默认设置。
#
#2.如果没有碎片，就不需要启用此功能
#问题。
#
#3.一旦您遇到碎片，您可以在以下情况下启用此功能：
#需要命令“CONFIG SET activedefrag yes”。
#
#配置参数能够微调
#碎片整理过程。如果你不确定他们是什么意思
#保持默认值不变是个好主意。
#已启用活动碎片整理
# activedefrag no

#启动活动碎片整理的最小碎片浪费量
# active-defrag-ignore-bytes 100mb

#启动活动碎片整理的最小碎片百分比
# active-defrag-threshold-lower 10

#使用最大努力的最大碎片百分比
# active-defrag-threshold-upper 100

#以CPU百分比表示的最小碎片整理工作量，在
#已达到阈值
# active-defrag-cycle-min 1

#以CPU百分比表示的碎片整理的最大工作量，当
#已达到阈值
# active-defrag-cycle-max 25

#将从中处理的set/hash/zset/list字段的最大数目
#主词典扫描
# active-defrag-max-scan-fields 1000

#默认情况下，将启用用于清除的Jemalloc后台线程
jemalloc-bg-thread yes

#可以将Redis的不同线程和进程固定到特定的
#系统中的CPU，以最大限度地提高服务器的性能。
#这对于将不同的Redis线程固定到不同的
#同时为了保证多个Redis实例运行
#在同一个主机中，将被固定到不同的CPU。
#
#通常，您可以使用“taskset”命令来执行此操作，但是
#在Linux和FreeBSD中，可以通过Redis配置直接实现这一点。
#
#您可以固定服务器/IO线程、bio线程、aof重写子进程和
#bgsave子进程。指定cpu列表的语法与
#taskset命令：
#
#将redis服务器/io线程设置为cpu相关性0,2,4,6：
# server_cpulist 0-7:2
#
#将bio线程设置为cpu亲和力1,3：
# bio_cpulist 1,3
#
#将aof rewrite子进程设置为cpu相关性8、9、10、11：
# aof_rewrite_cpulist 8-11
#
#将bgsave子进程设置为cpu affinity 1,10,11
# bgsave_cpulist 1,10-11

#在某些情况下，redis会发出警告，如果检测到错误，甚至会拒绝启动
#如果系统处于不良状态，则可以抑制这些警告
#通过设置以下配置，该配置采用以空格分隔的警告列表
#压制
#
# ignore-warnings ARM64-COW-BUG
